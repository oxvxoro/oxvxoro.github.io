---
title: "ASP.NET Core 01. ASP.NET 소개 및 작동 원리"
date: 2026-02-12 19:00:00 +0900
categories: [ASP.NET Core]
tags: [asp.net, c#]
toc: true
pin: false
math: true
---

ASP.NET Core를 본격적으로 다루기 전, 이 프레임워크가 도대체 무엇이며, 내부적으로 어떤 메커니즘을 통해 클라이언트의 요청을 처리하는지 기초부터 단단히 다지기 위해 정리해본다.

단순히 "코드를 이렇게 짜면 된다"는 방법론을 넘어, **프레임워크의 설계 철학**과 **HTTP 요청의 생명주기**를 이해하는 것이 이번 포스팅의 목표다.

---

## 1. ASP.NET Core: 왜 배워야 하는가?

과거 윈도우 서버(IIS)에 종속적이었던 레거시 ASP.NET과 달리, **ASP.NET Core**는 완전히 새롭게 다시 태어난 프레임워크다. 마이크로소프트가 "앞으로의 모든 웹 개발은 이것으로 하라"고 못 박은 데에는 확실한 이유가 있다.

### 🚀 핵심 키워드 3가지
1.  **Cross-Platform (크로스 플랫폼):**
    * 가장 큰 변화다. 이제 윈도우뿐만 아니라 **Linux, macOS**에서도 개발하고 배포할 수 있다.
    * 이게 왜 중요하냐면, **Docker 컨테이너** 환경이나 저렴한 리눅스 서버 호스팅을 활용할 수 있어 인프라 비용을 획기적으로 줄일 수 있기 때문이다.
2.  **Performance (성능):**
    * 태생부터 성능을 최우선 기능(Feature)으로 두고 설계되었다.
    * 모듈식 설계로 필요한 기능만 골라 쓸 수 있어 가볍고 빠르다. 벤치마크 사이트에서도 상위권을 휩쓸고 있다.
3.  **Modern & Open Source:**
    * GitHub에 소스 코드가 공개되어 투명하게 개발되며, 현대적인 소프트웨어 디자인 패턴이 적용되어 있다.

> **참고:** 기존의 `.NET Framework`는 이제 신규 업데이트 없이 유지에 들어갔다. 버그나 보안 패치는 해주지만 새로운 기능은 추가되지 않는다. 신규 프로젝트라면 무조건 `.NET 7` 이상의 런타임 위에서 돌아가는 ASP.NET Core를 선택해야 한다.

---

## 2. 무엇을 만들 수 있는가? (The Ecosystem)

ASP.NET Core는 단순한 웹 프레임워크가 아니라 거대한 **플랫폼**이다. 내가 만들고자 하는 서비스의 성격에 따라 최적의 도구를 골라 쓸 수 있다.

### 📡 백엔드 API (Data-Centric)
프론트엔드(React, Vue, 모바일 앱)와 데이터를 주고받기 위한 서버를 구축할 때 사용한다.

* **Minimal APIs**:
    * 복잡한 클래스나 컨트롤러 없이, 함수 몇 줄로 API를 만들 수 있다.
    * 마이크로서비스(MSA)나 간단한 프로토타입을 만들 때 압도적인 생산성을 보여준다.
* **Web APIs**:
    * 전통적인 `Controller` 기반 방식이다.
    * 구조가 잡혀있어 대규모 협업이나 복잡한 라우팅 규칙이 필요한 엔터프라이즈급 API에 적합하다.
* **gRPC**:
    * JSON 대신 바이너리 프로토콜(Protobuf)을 사용한다.
    * 서버 간 통신(Server-to-Server)에서 극한의 성능과 효율이 필요할 때 사용한다.

### 🖥️ 서버 사이드 렌더링 (HTML-Centric)
서버에서 완성된 HTML을 내려주는 전통적인 방식이다. SEO(검색엔진 최적화)가 중요할 때 유리하다.

* **Razor Pages**:
    * MVVM 패턴과 유사하게 페이지 단위로 로직을 작성한다. MVC보다 구조가 직관적이라 생산성이 높다.
* **MVC (Model-View-Controller)**:
    * 역할 분리가 확실해야 하는 대규모 웹 애플리케이션에서 표준처럼 사용된다.

### ✨ Blazor (Interactive Web UI)
C# 개발자에게는 꿈의 기술이다. **자바스크립트 없이 C#으로** 리치한 웹 UI를 만든다.

* **Blazor WebAssembly (WASM)**:
    * 브라우저에 `.dll` 파일과 런타임을 다운로드해 실행한다. React/Vue와 같은 클라이언트 사이드 SPA(Single Page App)다.
* **Blazor Server**:
    * 브라우저와 서버가 **WebSocket(SignalR)**으로 연결된다.
    * 사용자가 클릭하면 서버에서 로직을 처리하고, "변경된 부분(DOM)만 업데이트해라"라고 브라우저에 신호를 보낸다.
    * 소스 코드가 서버에 있어 보안에 강력하고, 다운로드 용량이 작아 초기 로딩이 빠르다.

---

## 3. 아키텍처: 계층 구조 이해하기

ASP.NET Core 앱을 뜯어보면 마치 양파처럼 계층(Layer)이 나뉘어 있다. 이 흐름을 이해하는 것이 중요하다.

1.  **ASP.NET Core Framework (가장 바깥쪽)**
    * 클라이언트로부터 들어오는 복잡한 HTTP 요청을 가장 먼저 받는다.
    * TCP/IP 연결 관리, 요청 파싱 등 로우 레벨 작업을 처리한다.
2.  **Handlers (중간 계층)**
    * 프레임워크는 요청을 분석해 적절한 핸들러(`Controller`, `Razor Page` 등)를 호출한다.
    * 우리가 흔히 작성하는 "컨트롤러 코드"가 여기에 해당한다.
3.  **Business Logic (핵심 코어)**
    * 핸들러는 실제 업무 처리를 위해 **비즈니스 로직(Domain Logic)**을 호출한다.
    * *핵심:* 이 비즈니스 로직은 **순수한 C# 클래스(POCO)**여야 한다. ASP.NET Core 라이브러리에 의존하지 않아야 나중에 프레임워크가 바뀌거나 단위 테스트(Unit Test)를 할 때 문제가 없다.

---

## 4. 작동 원리 심층 분석 (Under the Hood)

주소창에 URL을 입력하고 엔터를 치는 그 짧은 순간, 서버 내부에서는 어떤 일이 벌어질까?

### 4.1 HTTP 요청의 라이프사이클
기본적으로 웹은 **요청(Request)과 응답(Response)**의 티키타카다.
* 브라우저가 서버에 요청을 보낸다. (예: `GET /home`)
* 서버는 HTML을 만들어 응답한다.
* 브라우저는 HTML을 해석하다가 이미지, CSS, JS 파일이 나오면 **추가 요청**을 보낸다.
    * 아마존닷컴 같은 대형 사이트는 메인 페이지 하나를 띄우기 위해 수백 번의 요청이 오간다.
    * HTTP는 **Stateless(무상태)** 프로토콜이라, 서버는 이전 요청을 기억하지 못한다.

### 4.2 Kestrel과 HttpContext의 마법
ASP.NET Core 애플리케이션은 실행될 때 내부에 **자체 웹 서버**를 구동한다. 이것이 바로 **Kestrel**이다.

**Step 1: 수신 (Kestrel의 역할)**
인터넷 선을 타고 0과 1로 이루어진 날것의(Raw) 데이터 패킷이 서버에 도착한다. Kestrel은 이 복잡한 데이터를 받아서 C# 개발자가 다루기 쉬운 `HttpContext`라는 객체로 변환한다.

> **HttpContext란?**
> 요청에 대한 모든 정보(누가 보냈는지, 어떤 URL인지, 헤더는 뭔지, 쿠키는 있는지 등)를 담고 있는 거대한 '봉투'라고 생각하면 된다.

**Step 2: 미들웨어 파이프라인과 로직 처리**
이제 우리가 작성한 애플리케이션 코드가 등장할 차례다. `HttpContext`라는 봉투를 열어보고 로직을 수행한다.
* 인증(Authentication): "로그인한 사용자인가?"
* 라우팅(Routing): "어떤 컨트롤러를 실행해야 하지?"
* 비즈니스 로직: "DB에서 상품 목록 가져오기"

이 모든 과정을 거쳐 "어떤 응답을 줄지" 결정한다. (HTML을 줄지, JSON을 줄지, 404 에러를 줄지)

**Step 3: 응답 반환**
처리가 끝나면 애플리케이션은 결과물을 다시 Kestrel에게 넘긴다. Kestrel은 `HttpContext`나 C# 객체로 되어 있는 응답을 다시 네트워크를 통해 전송할 수 있는 **HTTP 원시 응답(Raw HTTP Response)**으로 변환하여 브라우저에게 쏘아준다.

---

## 5. 마치며: 개발자의 역할

결국 ASP.NET Core를 사용한다는 것은 **Kestrel이 만들어준 `HttpContext`를 받아서, 적절한 처리를 한 뒤, 올바른 응답을 돌려주는 로직을 짜는 것**으로 요약할 수 있다.

* **다재다능함:** 웹사이트, 고성능 API, 실시간 통신까지 커버한다.
* **구조적:** 네트워크의 복잡함은 프레임워크에 맡기고, 우리는 **비즈니스 로직**에만 집중하면 된다.

다음 포스팅부터는 이 강력한 도구를 활용해 실제로 프로젝트를 구성하고 코드를 작성하는 방법을 하나씩 기록해 볼 예정이다.